// Copyright Brace Yourself Games. All Rights Reserved.

#pragma once

#include "Widget/BYGInlineTextTooltip.h"
#include "Widget/BYGRichTextBlock.h"

#include "Blueprint/UserWidget.h"
#include "Components/Widget.h"
#include "Internationalization/TextTransformer.h"
#include "Kismet/KismetSystemLibrary.h"
#include "UObject/ConstructorHelpers.h"
#include "Widgets/Images/SImage.h"
#include "Widgets/SOverlay.h"
#include "Widgets/Text/SRichTextBlock.h"
#include "BYGRichTextModule.h"
#include "BYGStyleDisplayType.h"

#include "BYGRichTextProperty.generated.h"

UENUM()
enum class EBYGBrushLocationType
{
	Single,
	Folder,
};

DECLARE_DELEGATE( FBYGOnPropertyPropertyChangedSignature );

UCLASS( Abstract )
class BYGRICHTEXT_API UBYGRichTextPropertyBase : public UObject
{
	GENERATED_BODY()

public:
	// Inline and Block
	virtual void TransformString( FString& Str ) const {}
	virtual bool OutputReplacement( FText& Out ) const { return false; }
	// Block only
	virtual void ApplyToTextBlock( TSharedRef<SRichTextBlock>& TextBlock ) const {}
	virtual TSharedRef<SWidget> WrapBlock( TSharedRef<SWidget>& Widget, UBYGRichTextBlock* OuterBlock, const TMap<FString, FString>& Payload ) const { return Widget; }
	// Inline only
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const {}
	// Some properties can only be applied to Block, some to Inline, some to both.
	virtual bool GetSupportsDisplayType( EBYGStyleDisplayType Style ) const { return true; }

	// If true, this property will always be included by default. e.g. always set text to size 12 even if no TextSize property is found
	// Useful for providing sensible defaults for new users. e.g. seeing text in a default typeface rather than broken glyphs
	bool GetShouldApplyToDefault() const { return bShouldApplyToDefault; }
	virtual bool RequiresInlineTextBlock() const { return false; }

	// We have to use this, and not GetClass()->GetFName() because BP-defined instances of properties were returning different names
	// and we need this as a "unique" identifier of this "class" of property
	// Maybe there's a better way of doing this, this will have to do for now.
	virtual FName GetTypeID() const { return TypeID; }

	// This is something we can used to uniquely identify a property, it is generated by the system, you don't need to touch it
	FString GetInlineID() const
	{
		ensure( !CachedInlineID.IsEmpty() );
		return CachedInlineID;
	}
	// Because mutable
	void SetInlineID( int32 InID ) const
	{
		if ( InID == InlineID ) return;
		InlineID = InID;
		ensure( InlineID != INDEX_NONE );
		CachedInlineID = FString::Printf( TEXT( "%d" ), InlineID );
	}

	void BeginDestroy() override;


#if WITH_EDITOR
	FBYGOnPropertyPropertyChangedSignature OnPropertyPropertyChangedDelegate;

	// Using these to hackily bubble-up changes to the stylesheet etc. so we can change stuff in real-time
	virtual void PostEditChangeProperty( struct FPropertyChangedEvent& PropertyChangedEvent ) override;
	virtual void PostEditChangeChainProperty( struct FPropertyChangedChainEvent& PropertyChangedEvent ) override;
#endif

protected:
	bool bShouldApplyToDefault = false;
	// Wuff, mutable here is stinky code
	UPROPERTY()
		mutable int32 InlineID = INDEX_NONE;
	// Wuff, mutable here is stinky code
	UPROPERTY()
		mutable FString CachedInlineID;
	FName TypeID = FName("Base");

	friend class FBYGRichTextStyleCustomization;
	friend class FBYGRichTextStylesheetIDs;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Text Color", DisplayOrder = 20 ) )
class BYGRICHTEXT_API UBYGRichTextColorProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextColorProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "TextColor";
	}
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetColorAndOpacity( TextColor );
	}
	void SetColor( const FLinearColor& InTextColor ) { TextColor = InTextColor; }

protected:
	UPROPERTY( EditAnywhere )
		FLinearColor TextColor = FLinearColor::White;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Font", DisplayOrder = 0 ) )
class BYGRICHTEXT_API UBYGRichTextTypefaceProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextTypefaceProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "Typeface";
		static ConstructorHelpers::FObjectFinder<UObject> RobotoFontObj( TEXT( "/Engine/EngineFonts/Roboto" ) );
		ensure( RobotoFontObj.Object );
		FontObject = RobotoFontObj.Object;
	}
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.Font.FontObject = FontObject;
	}

	void SetFont( const UObject* InFont ) { FontObject = InFont; }


protected:
	UPROPERTY( EditAnywhere, meta = ( AllowedClasses = "Font", DisplayName = "Font Family" ) )
		const UObject* FontObject;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Font Style", DisplayOrder = 1 ) )
class BYGRICHTEXT_API UBYGRichTextTypeVariantProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextTypeVariantProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "TypeVariant";
	}
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetTypefaceFontName( TypefaceFontName );
	}

	void SetName( const FName& InName ) { TypefaceFontName = InName; }
	FName GetName() const { return TypefaceFontName; }

protected:
	// TODO: Custom editor should fill this with the right object if RichTextTypefaceProperty is defined,
	//       and make it read-only.
	//       If there is no RichTextTypefaceProperty, user should be able to select the typeface.
	//       With the object set, copy how SlateFontInfoCustomization works in filling out the list of
	//       TypefaceFontNames in a dropdown.
	UPROPERTY( EditAnywhere, meta = ( AllowedClasses = "Font", DisplayName = "Font Family" ) )
		const UObject* FontObject;

	/** The name of the font to use from the default typeface (None will use the first entry) */
	UPROPERTY( EditAnywhere, meta = ( DisplayName = "Typeface" ) )
		FName TypefaceFontName;

};



UCLASS( EditInlineNew, meta = ( DisplayName = "Text Size", DisplayOrder = 10 ) )
class BYGRICHTEXT_API UBYGRichTextSizeProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextSizeProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "Size";
	}
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetFontSize( Size );
	}

	void SetSize( uint16 InSize ) { Size = InSize; }
	uint16 GetSize() const { return Size; }

protected:
	UPROPERTY( EditAnywhere )
		uint16 Size = 12;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Text Case", DisplayOrder = 15 ) )
class BYGRICHTEXT_API UBYGRichTextCaseProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextCaseProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "Case";
	}
	virtual void TransformString( FString& Str ) const override
	{
		// TODO: The SRichTextBlock seems to support ETextTransformPolicy, maybe this isn't needed?
		if ( Case == ETextTransformPolicy::ToUpper )
		{
			Str = FTextTransformer::ToUpper( Str );
		}
		else if ( Case == ETextTransformPolicy::ToLower )
		{
			Str = FTextTransformer::ToLower( Str );
		}
	}
	void SetCase( ETextTransformPolicy InCase ) { Case = InCase; }
	ETextTransformPolicy GetCase() const { return Case; }

protected:
	UPROPERTY( EditAnywhere )
		ETextTransformPolicy Case = ETextTransformPolicy::ToUpper;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Text Shadow", DisplayOrder = 21 ) )
class BYGRICHTEXT_API UBYGRichTextShadowProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextShadowProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "Shadow";
	}
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetShadowColorAndOpacity( ShadowColor );
		Style.SetShadowOffset( ShadowOffset );
	}

	void SetColor( const FLinearColor& InShadowColor ) { ShadowColor = InShadowColor; }
	void SetOffset( const FIntPoint& InShadowOffset ) { ShadowOffset = InShadowOffset; }

protected:
	UPROPERTY( EditAnywhere )
		FLinearColor ShadowColor = FLinearColor::Black;
	UPROPERTY( EditAnywhere )
		FIntPoint ShadowOffset = FIntPoint( 1, 1 );
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Justification", DisplayOrder = 30 ) )
class BYGRICHTEXT_API UBYGRichTextJustificationProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextJustificationProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "Justification";
	}
	virtual void ApplyToTextBlock( TSharedRef<SRichTextBlock>& TextBlock ) const override
	{
		TextBlock->SetJustification( Justification );
	}

	void SetJustification( TEnumAsByte<ETextJustify::Type> InJustification ) { Justification = InJustification; }
	virtual bool GetSupportsDisplayType( EBYGStyleDisplayType Style ) const override { return Style == EBYGStyleDisplayType::Block; }

//protected:
	UPROPERTY( EditAnywhere )
		TEnumAsByte<ETextJustify::Type> Justification = ETextJustify::Left;
};



UCLASS( EditInlineNew, meta = ( DisplayName = "Margin", DisplayOrder = 32 ) )
class BYGRICHTEXT_API UBYGRichTextMarginProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextMarginProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "Margin";
	}
	virtual void ApplyToTextBlock( TSharedRef<SRichTextBlock>& TextBlock ) const override
	{
		TextBlock->SetMargin( Margin );
	}

	void SetMargin( const FMargin& InMargin ) { Margin = InMargin; }
	FMargin GetMargin() const { return Margin; }

protected:
	UPROPERTY( EditAnywhere )
		FMargin Margin;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Line Height Percentage", DisplayOrder = 33 ) )
class BYGRICHTEXT_API UBYGRichTextLineHeightPercentProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextLineHeightPercentProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "LineHeightPercent";
	}
	virtual void ApplyToTextBlock( TSharedRef<SRichTextBlock>& TextBlock ) const override
	{
		TextBlock->SetLineHeightPercentage( LineHeight );
	}

	void SetLineHeight( float InLineHeight ) { LineHeight = InLineHeight; }

protected:
	UPROPERTY( EditAnywhere )
		float LineHeight = 1;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Line Wrapping", DisplayOrder = 31 ) )
class BYGRICHTEXT_API UBYGRichTextLineWrapProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextLineWrapProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		bShouldApplyToDefault = true;
		TypeID = "LineWrap";
	}
	virtual void ApplyToTextBlock( TSharedRef<SRichTextBlock>& TextBlock ) const override
	{
		TextBlock->SetWrappingPolicy( WrappingPolicy );
		TextBlock->SetAutoWrapText( bAutoWrap );
	}
	void SetAutoWrap( bool bInAutoWrap ) { bAutoWrap = bInAutoWrap; }
	void SetTextWrappingPolicy( ETextWrappingPolicy InWrappingPolicy ) { WrappingPolicy = InWrappingPolicy; }
	virtual bool GetSupportsDisplayType( EBYGStyleDisplayType Style ) const override { return Style == EBYGStyleDisplayType::Block; }

protected:
	UPROPERTY( EditAnywhere )
		bool bAutoWrap = true;
	UPROPERTY( EditAnywhere )
		ETextWrappingPolicy WrappingPolicy = ETextWrappingPolicy::DefaultWrapping;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Background", DisplayOrder = 22 ) )
class BYGRICHTEXT_API UBYGRichTextBackgroundBrushProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextBackgroundBrushProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "BackgroundBrush";
	}
	virtual TSharedRef<SWidget> WrapBlock( TSharedRef<SWidget>& TextBlock, UBYGRichTextBlock* OuterBlock, const TMap<FString, FString>& Payload ) const override
	{
		if ( BrushLocationType == EBYGBrushLocationType::Folder )
		{
			// Find the file from the img payload

		}

		TSharedRef<SOverlay> NewOverlay = SNew( SOverlay )
		+ SOverlay::Slot()
			.HAlign( ImageHAlign )
			.VAlign( ImageVAlign )
			.Padding( ImagePadding )
		[
			SNew( SImage )
			.Image( &Brush )
		]
		+ SOverlay::Slot()
			.HAlign( HAlign_Fill )
			.VAlign( VAlign_Fill )
		[
			TextBlock
		];

		return NewOverlay;
	}

	void SetBrush( const FSlateBrush& InBrush ) { Brush = InBrush; }
	void SetHAlign( TEnumAsByte<EHorizontalAlignment> InImageHAlign ) { ImageHAlign = InImageHAlign; }
	void SetVAlign( TEnumAsByte<EVerticalAlignment> InImageVAlign ) { ImageVAlign = InImageVAlign; }
	void SetMargin( const FMargin& InImagePadding ) { ImagePadding = InImagePadding; }

	virtual bool RequiresInlineTextBlock() const { return true; }
protected:
	UPROPERTY( EditAnywhere )
		EBYGBrushLocationType BrushLocationType = EBYGBrushLocationType::Single;
	UPROPERTY( EditAnywhere, meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Single" ) )
		FSlateBrush Brush = FSlateNoResource();
	UPROPERTY( EditAnywhere, meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Folder", ContentDir ) )
		FDirectoryPath BrushDirectory;
	UPROPERTY( EditAnywhere )
		TEnumAsByte<EHorizontalAlignment> ImageHAlign = EHorizontalAlignment::HAlign_Fill;
	UPROPERTY( EditAnywhere )
		TEnumAsByte<EVerticalAlignment> ImageVAlign = EVerticalAlignment::VAlign_Fill;
	UPROPERTY( EditAnywhere )
		FMargin ImagePadding;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Text Replacement", DisplayOrder = 50 ) )
class BYGRICHTEXT_API UBYGRichTextReplacementProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextReplacementProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "TextReplacement";
	}
	virtual bool OutputReplacement( FText& Out ) const override
	{
		Out = Replacement;
		return true;
	}

protected:
	UPROPERTY( EditAnywhere )
		FText Replacement;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Inline Image", DisplayOrder = 51 ) )
class BYGRICHTEXT_API UBYGRichTextInlineBrushProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextInlineBrushProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		TypeID = "InlineBrush";
	}
	virtual TSharedRef<SWidget> WrapBlock( TSharedRef<SWidget>& TextBlock, UBYGRichTextBlock* OuterBlock, const TMap<FString, FString>& Payload ) const override
	{
		const FSlateBrush* BrushToUse = &Brush;
		if ( BrushLocationType == EBYGBrushLocationType::Folder )
		{
			// Find the file from the img payload
			FBYGRichTextModule& RichTextModule = FModuleManager::GetModuleChecked<FBYGRichTextModule>( TEXT( "BYGRichText" ) );
			// GetIconBrush will return a null brush if the icon is not found at this path
			const FVector2D Size = FVector2D( 20, 20 );
			
			FString DirName = BrushDirectory.Path;
			if ( !DirName.EndsWith( "/" ) )
			{
				DirName += "/";
			}
			const FString PayloadImgName = Payload.Contains( "img" ) ? Payload[ "img" ] : "";
			BrushToUse = RichTextModule.GetIconBrush( FString::Printf( TEXT( "%s%s%s%s.%s%s%s" ), *DirName, *Prefix, *PayloadImgName, *Suffix, *Prefix, *PayloadImgName, *Suffix ), Size );
		}

		TSharedRef<SOverlay> NewOverlay = SNew( SOverlay )
		+ SOverlay::Slot()
			.HAlign( ImageHAlign )
			.VAlign( ImageVAlign )
			.Padding( ImagePadding )
		[
			SNew( SImage )
			.Image( BrushToUse )
		]
		+ SOverlay::Slot()
			.HAlign( HAlign_Fill )
			.VAlign( VAlign_Fill )
		[
			TextBlock
		];

		return NewOverlay;
	}

	void SetBrushDirectory( const FString& InDirectoryPath ) { BrushDirectory.Path = InDirectoryPath; }
	void SetBrush( const FSlateBrush& InBrush ) { Brush = InBrush; }
	void SetHAlign( TEnumAsByte<EHorizontalAlignment> InImageHAlign ) { ImageHAlign = InImageHAlign; }
	void SetVAlign( TEnumAsByte<EVerticalAlignment> InImageVAlign ) { ImageVAlign = InImageVAlign; }
	void SetMargin( const FMargin& InImagePadding ) { ImagePadding = InImagePadding; }

	virtual bool RequiresInlineTextBlock() const { return true; }
protected:
	UPROPERTY( EditAnywhere, Category = "File" )
		EBYGBrushLocationType BrushLocationType = EBYGBrushLocationType::Single;
	UPROPERTY( EditAnywhere, Category = "File", meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Single" ) )
		FSlateBrush Brush = FSlateNoResource();
	UPROPERTY( EditAnywhere, Category = "File", meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Folder", ContentDir ) )
		FDirectoryPath BrushDirectory;
	UPROPERTY( EditAnywhere, Category = "File", meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Folder" ) )
		FString Prefix;
	UPROPERTY( EditAnywhere, Category = "File", meta = ( EditCondition = "BrushLocationType == EBYGBrushLocationType::Folder" ) )
		FString Suffix;
	UPROPERTY( EditAnywhere, Category = "Appearance" )
		TEnumAsByte<EHorizontalAlignment> ImageHAlign = EHorizontalAlignment::HAlign_Center;
	UPROPERTY( EditAnywhere, Category = "Appearance" )
		TEnumAsByte<EVerticalAlignment> ImageVAlign = EVerticalAlignment::VAlign_Center;
	UPROPERTY( EditAnywhere, Category = "Appearance" )
		FMargin ImagePadding;
};


/**
* Interface for tool tips.
*/

DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam( UWidget*, FBYGGetWidget, UBYGRichTextBlock*, Owner );
class FBYGDelegateToolTip : public IToolTip
{
public:

	/**
	* Gets the widget that this tool tip represents.
	*
	* @return The tool tip widget.
	*/
	virtual TSharedRef<class SWidget> AsWidget() override
	{
		return GetContentWidget();
	}

	/**
	* Gets the tool tip's content widget.
	*
	* @return The content widget.
	*/
	virtual TSharedRef<SWidget> GetContentWidget() override
	{
		if ( CachedToolTip.IsValid() )
		{
			return CachedToolTip.ToSharedRef();
		}

		UWidget* Widget = ToolTipWidgetDelegate.Execute( OuterBlock.Get() );
		if ( Widget )
		{
			CachedToolTip = Widget->TakeWidget();
			return CachedToolTip.ToSharedRef();
		}

		return SNullWidget::NullWidget;
	}

	/**
	* Sets the tool tip's content widget.
	*
	* @param InContentWidget The new content widget to set.
	*/
	virtual void SetContentWidget(const TSharedRef<SWidget>& InContentWidget) override
	{
		CachedToolTip = InContentWidget;
	}

	/**
	* Checks whether this tool tip has no content to display right now.
	*
	* @return true if the tool tip has no content to display, false otherwise.
	*/
	virtual bool IsEmpty() const override
	{
		return !ToolTipWidgetDelegate.IsBound();
	}

	/**
	* Checks whether this tool tip can be made interactive by the user (by holding Ctrl).
	*
	* @return true if it is an interactive tool tip, false otherwise.
	*/
	virtual bool IsInteractive() const override
	{
		return false;
	}

	virtual void OnClosed() override
	{
		//TODO Notify interface implementing widget of closure

		CachedToolTip.Reset();
	}

	virtual void OnOpening() override
	{
		//TODO Notify interface implementing widget of opening
	}

	TWeakObjectPtr<UBYGRichTextBlock> OuterBlock;

public:
	FBYGGetWidget ToolTipWidgetDelegate;


private:
	TSharedPtr<SWidget> CachedToolTip;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Tooltip", DisplayOrder = 52 ) )
class BYGRICHTEXT_API UBYGRichTextTooltipProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	UBYGRichTextTooltipProperty( const FObjectInitializer& ObjectInitializer )
		: Super( ObjectInitializer )
	{
		ToolTipWidgetDelegate.BindUFunction( this, GET_FUNCTION_NAME_CHECKED( UBYGRichTextTooltipProperty, CreateTooltip ) );
		TypeID = "Tooltip";
	}

	UFUNCTION()
		UWidget* CreateTooltip( UBYGRichTextBlock* InOuter );

	virtual TSharedRef<SWidget> WrapBlock( TSharedRef<SWidget>& TextBlock, UBYGRichTextBlock* InOuterBlock, const TMap<FString, FString>& Payload ) const override
	{
#if WITH_EDITOR
		if ( InOuterBlock->bIsSlatePreview )
			return TextBlock;
#endif

		TSharedRef<FBYGDelegateToolTip> ToolTip = MakeShareable( new FBYGDelegateToolTip() );
		ToolTip->ToolTipWidgetDelegate = ToolTipWidgetDelegate;
		ToolTip->OuterBlock = InOuterBlock;
		TextBlock.Get().SetToolTip( ToolTip );
		return TextBlock;
	}

	virtual TSharedRef<SWidget> CreateInline( TSharedRef<SWidget>& TextBlock, UBYGRichTextBlock* InOuterBlock )
	{
#if WITH_EDITOR
		if ( InOuterBlock->bIsSlatePreview )
			return TextBlock;
#endif

		TSharedRef<FBYGDelegateToolTip> ToolTip = MakeShareable( new FBYGDelegateToolTip() );
		ToolTip->ToolTipWidgetDelegate = ToolTipWidgetDelegate;
		ToolTip->OuterBlock = InOuterBlock;
		TextBlock.Get().SetToolTip( ToolTip );
		return TextBlock;
	}

	// UserWidgetClass can optionally implement BYGInlineTooltip interface to receive information
	UPROPERTY( EditAnywhere )
		TSubclassOf<UUserWidget> UserWidgetClass;

protected:
	//TWeakObjectPtr<UWidget> OuterBlock;

	FBYGGetWidget ToolTipWidgetDelegate;
};


#if 0
// Disabled until I implement a custom Marshaller
UCLASS( EditInlineNew, meta = ( DisplayName = "Strikethrough", DisplayOrder = 40 ) )
class BYGRICHTEXT_API UBYGRichTextStrikeProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetStrikeBrush( Brush );
	}
	void SetBrush( const FSlateBrush& InBrush ) { Brush = InBrush; }

protected:
	UPROPERTY( EditAnywhere )
		FSlateBrush Brush = FSlateNoResource();
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Highlight", DisplayOrder = 41 ) )
class BYGRICHTEXT_API UBYGRichTextHighlightProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetHighlightColor( Color );
		Style.SetHighlightShape( Brush );
	}
	void SetBrush( const FSlateBrush& InBrush ) { Brush = InBrush; }
	void SetColor( const FLinearColor& InColor ) { Color = InColor; }

protected:
	UPROPERTY( EditAnywhere )
		FSlateBrush Brush = FSlateNoResource();
	UPROPERTY( EditAnywhere )
		FLinearColor Color = FLinearColor::White;
};

UCLASS( EditInlineNew, meta = ( DisplayName = "Underline", DisplayOrder = 42 ) )
class BYGRICHTEXT_API UBYGRichTextUnderlineProperty : public UBYGRichTextPropertyBase
{
	GENERATED_BODY()

public:
	virtual void ApplyToTextStyle( FTextBlockStyle& Style ) const
	{
		Style.SetUnderlineBrush( Brush );
	}
	void SetBrush( const FSlateBrush& InBrush ) { Brush = InBrush; }

protected:
	UPROPERTY( EditAnywhere )
		FSlateBrush Brush = FSlateNoResource();
};
#endif
